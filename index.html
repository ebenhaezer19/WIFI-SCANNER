<!DOCTYPE html>
<html>
<head>
    <title>WIFROG v.1.0.0</title>
    <link rel="icon" type="image/png" href="./assets/logo.png">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #0E1026;
        }
        .header {
            background-color: #0E1026;
            color: white;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .header img {
            width: 50px;
            height: 50px;
            object-fit: contain;
        }
        .header-text {
            flex: 1;
        }
        .header-text h1 {
            margin: 0;
            font-size: 2em;
        }
        .header-text p {
            margin: 5px 0 0 0;
            opacity: 0.8;
        }
        .network {
            background-color: #161939;
            border: 1px solid rgba(255,255,255,0.1);
            margin: 10px 0;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
        }
        .network:hover {
            box-shadow: 0 2px 5px rgba(255,255,255,0.1);
            background-color: #1c2049;
        }
        .network.selected {
            border-color: #2196f3;
            background-color: #1c2049;
        }
        .control-panel {
            margin-top: 20px;
            padding: 20px;
            background-color: #161939;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .danger-button {
            background-color: #ff4444;
        }
        .danger-button:hover {
            background-color: #cc0000;
        }
        .warning-button {
            background-color: #ffbb33;
        }
        .warning-button:hover {
            background-color: #ff8800;
        }
        .control-button {
            background-color: #2196f3;
        }
        .control-button:hover {
            background-color: #1976d2;
        }
        .results {
            margin-top: 20px;
            padding: 20px;
            background-color: #161939;
            border-radius: 5px;
            max-height: 400px;
            overflow-y: auto;
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .error {
            color: #ff4444;
            background-color: rgba(255,68,68,0.1);
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px solid rgba(255,68,68,0.2);
        }
        .success {
            color: #00C851;
            background-color: rgba(0,200,81,0.1);
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px solid rgba(0,200,81,0.2);
        }
        button {
            background-color: #2196f3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #1976d2;
        }
        button:disabled {
            background-color: #64b5f6;
            cursor: not-allowed;
        }
        input, select {
            padding: 8px;
            margin: 5px 0;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            width: 200px;
            background-color: #0E1026;
            color: white;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #2196f3;
        }
        .progress-container {
            margin-top: 20px;
            padding: 20px;
            background-color: #161939;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #0E1026;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .progress-fill {
            height: 100%;
            background-color: #2196f3;
            width: 0%;
            transition: width 0.3s ease;
        }
        .attempt-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            padding: 10px;
            background-color: #0E1026;
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .attempt-item {
            padding: 5px;
            margin: 2px 0;
            border-radius: 3px;
            animation: fadeIn 0.3s ease;
            color: white;
        }
        .attempt-item.testing {
            background-color: rgba(33,150,243,0.1);
        }
        .attempt-item.failed {
            background-color: rgba(255,68,68,0.1);
        }
        .attempt-item.success {
            background-color: rgba(0,200,81,0.1);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .stats {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
        }
        .stat-item {
            text-align: center;
            flex: 1;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            margin: 0 5px;
        }
        .bruteforce-visual {
            font-family: monospace;
            font-size: 32px;
            text-align: center;
            padding: 30px;
            background-color: #000;
            color: #0f0;
            border-radius: 5px;
            margin: 20px 0;
            letter-spacing: 4px;
            overflow: hidden;
            white-space: nowrap;
            height: 100px;
            line-height: 100px;
        }
        .char-container {
            display: inline-block;
            width: 30px;
            height: 40px;
            margin: 0 4px;
            position: relative;
            overflow: hidden;
        }
        .char {
            position: absolute;
            animation: scrollChars 0.1s linear infinite;
        }
        @keyframes scrollChars {
            0% { transform: translateY(0); }
            100% { transform: translateY(-100%); }
        }
        .success-char {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            animation: none;
        }
        .testing-char {
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
        }
        .failed-char {
            color: #ff0000;
            text-shadow: 0 0 5px #ff0000;
        }
        .terminal {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            height: 200px;
            overflow-y: auto;
            position: relative;
        }
        .terminal-input {
            background-color: transparent;
            border: none;
            color: #0f0;
            font-family: monospace;
            width: 100%;
            padding: 5px;
            outline: none;
        }
        .terminal-output {
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        .terminal-prompt {
            color: #0f0;
            margin-right: 5px;
        }
        .attempt-line {
            font-family: monospace;
            font-size: 14px;
            color: #0f0;
            margin: 2px 0;
            white-space: pre;
        }
        .scrolling-char {
            display: inline-block;
            animation: charScroll 0.5s ease-in-out;
            margin-right: 2px;
        }
        @keyframes charScroll {
            0% { 
                transform: translateY(-20px);
                opacity: 0;
            }
            50% {
                color: #ff0;
            }
            100% { 
                transform: translateY(0);
                opacity: 1;
            }
        }
        .terminal {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            height: 300px;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 0 10px rgba(0,255,0,0.2);
        }
        .terminal-output {
            margin-bottom: 5px;
        }
        .network-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .network-details {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .detail-row {
            margin: 5px 0;
        }
        .detail-label {
            color: #000000;
            font-weight: bold;
            margin-right: 10px;
        }
        .vulnerabilities, .recommendations {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        .vuln-list, .rec-list {
            margin: 5px 0;
            padding-left: 20px;
            list-style-type: none;
        }
        .vuln-list li, .rec-list li {
            margin: 3px 0;
            padding-left: 20px;
            position: relative;
        }
        .vuln-list li:before {
            content: "⚠️";
            position: absolute;
            left: -5px;
        }
        .rec-list li:before {
            content: "✓";
            position: absolute;
            left: 0;
            color: #00C851;
        }
        .risk-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }
        .risk-badge.critical {
            background-color: rgba(255,0,0,0.2);
            color: #ff4444;
            border: 1px solid rgba(255,0,0,0.3);
        }
        .risk-badge.high {
            background-color: rgba(255,68,0,0.2);
            color: #ff8800;
            border: 1px solid rgba(255,68,0,0.3);
        }
        .risk-badge.medium {
            background-color: rgba(255,187,51,0.2);
            color: #ffbb33;
            border: 1px solid rgba(255,187,51,0.3);
        }
        .risk-badge.low {
            background-color: rgba(0,200,81,0.2);
            color: #00C851;
            border: 1px solid rgba(0,200,81,0.3);
        }
        .risk-badge.unknown {
            background-color: rgba(158,158,158,0.2);
            color: #9e9e9e;
            border: 1px solid rgba(158,158,158,0.3);
        }
        /* Advanced Security Analysis Styles */
        .advanced-security {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .security-section {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .security-section h5 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 1.1em;
        }
        .security-section h6 {
            margin: 10px 0 5px 0;
            color: #34495e;
            font-size: 0.9em;
        }
        .risk-indicator {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 3px;
            margin-bottom: 10px;
        }
        .risk-label {
            font-weight: bold;
            margin-right: 5px;
        }
        .risk-value {
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
        }
        .risk-value.Critical {
            background: #ff4444;
            color: white;
        }
        .risk-value.High {
            background: #ff8800;
            color: white;
        }
        .risk-value.Medium {
            background: #ffbb33;
            color: black;
        }
        .risk-value.Low {
            background: #00C851;
            color: white;
        }
        .risk-value.Unknown {
            background: #999999;
            color: white;
        }
        .details ul {
            list-style: none;
            padding-left: 0;
            margin: 5px 0;
        }
        .details ul li {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        .details ul li:last-child {
            border-bottom: none;
        }
        .details ul.indicators-list li,
        .details ul.threats-list li {
            color: #e74c3c;
        }
        .details ul.recommendations-list li {
            color: #27ae60;
        }
        .details ul.similar-networks-list li,
        .details ul.interference-list li {
            color: #e67e22;
        }
        .network-details {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
            color: #000000;
        }
        
        .network-details h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }
        
        .basic-info {
            margin-bottom: 30px;
            color: #000000;
        }
        
        .detail-row {
            display: flex;
            margin-bottom: 10px;
            align-items: center;
            color: #000000;
        }
        
        .detail-label {
            color: #000000;
            font-weight: bold;
            min-width: 150px;
        }
        
        .security-analysis {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .analysis-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            color: #000000;
        }
        
        .analysis-section h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #dee2e6;
        }
        
        .risk-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 8px;
            background: #fff;
            border-radius: 4px;
            color: #000000;
        }
        
        .risk-value {
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .risk-value.high {
            background: #ff4444;
            color: white;
        }
        
        .risk-value.medium {
            background: #ffbb33;
            color: white;
        }
        
        .risk-value.low {
            background: #00C851;
            color: white;
        }
        
        .indicators, .threats, .vulnerabilities, .interference, .recommendations, .similar-networks {
            margin-top: 15px;
        }
        
        .indicators-list, .threats-list, .vulnerabilities-list, .interference-list, .recommendations-list, .similar-networks-list {
            list-style-type: none;
            padding-left: 0;
            margin-top: 8px;
        }
        
        .indicators-list li, .threats-list li, .vulnerabilities-list li, .interference-list li, .recommendations-list li {
            padding: 8px;
            background: #fff;
            border-radius: 4px;
            margin-bottom: 5px;
            border-left: 3px solid #3498db;
        }
        
        .similar-networks-list li {
            padding: 12px;
            background: #fff;
            border-radius: 4px;
            margin-bottom: 8px;
            border-left: 3px solid #3498db;
            line-height: 1.4;
        }
        
        .threats-list li {
            border-left-color: #e74c3c;
        }
        
        .vulnerabilities-list li {
            border-left-color: #e67e22;
        }
        
        .recommendations-list li {
            border-left-color: #27ae60;
        }
        
        @media (max-width: 768px) {
            .security-analysis {
                grid-template-columns: 1fr;
            }
            
            .detail-label {
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="./assets/logo.png" alt="WIFROG Logo" onerror="this.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyBAMAAADsEZWCAAAAG1BMVEUAAAAzl/8AAAAzl/8zl/8zl/8zl/8zl/8zl/+HtQGBAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAQklEQVQ4jWNgQAX8DAzMDKhgAAPD/3///v1HAcxMTExMqED4////qICRkZERFbAyMrIyogJWJkZWJlTAwsDAwIgKAL9tEh+wfWDQAAAAAElFTkSuQmCC'">
        <div class="header-text">
            <h1>WIFROG v.1.0.0</h1>
            <p>Wifi Crack Attacker</p>
        </div>
    </div>

    <button onclick="scanNetworks()" id="scanBtn">Scan Networks</button>
    <div id="networks"></div>

    <div class="control-panel" id="controlPanel" style="display:none;">
        <h3>Investigation Parameters</h3>
        <input type="text" id="ssid" readonly>
        <select id="pattern">
            <option value="d">Numbers Only</option>
            <option value="dl">Numbers + Lowercase</option>
            <option value="dlu" selected>Numbers + Letters</option>
            <option value="dlus">All Characters</option>
        </select>
        <input type="number" id="minLength" value="8" min="4" max="12" placeholder="Min Length">
        <input type="number" id="maxLength" value="12" min="4" max="12" placeholder="Max Length">
        <input type="number" id="maxAttempts" value="1000" min="100" max="10000" placeholder="Max Attempts">
        <div class="button-group">
            <button onclick="startInvestigation(true)" id="simulateBtn">Brute Force Hack Simulation</button>
            <button onclick="startInvestigation(false)" id="crackBtn" class="danger-button">Real Attack (Dangerous)</button>
        </div>
    </div>

    <div class="progress-container" id="progressContainer" style="display:none;">
        <h3>Investigation Progress</h3>
        <div class="bruteforce-visual" id="bruteforceVisual"></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>
        <div class="terminal" id="terminal">
            <div id="terminalOutput"></div>
            <div style="display: flex;">
                <span class="terminal-prompt">$</span>
                <input type="text" class="terminal-input" id="terminalInput" placeholder="Type command (help for list of commands)" onkeypress="handleTerminalInput(event)">
            </div>
        </div>
        <div class="attempt-list" id="attemptList"></div>
    </div>

    <div class="results" id="results" style="display:none;">
        <h3>Investigation Results</h3>
        <div id="progress"></div>
        <div id="attempts"></div>
    </div>

    <div class="network-details" style="display: none;">
        <h3>Network Details</h3>
        <div class="basic-info">
            <div class="detail-row">
                <span class="detail-label">SSID:</span>
                <span class="ssid"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">BSSID:</span>
                <span class="bssid"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Signal:</span>
                <span class="signal"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Security:</span>
                <span class="security"></span>
            </div>
        </div>

        <div class="security-analysis">
            <div class="mac-spoofing analysis-section">
                <h4>MAC Address Analysis</h4>
                <div class="risk-row">
                    <span class="detail-label">Risk Level:</span>
                    <span class="risk-value"></span>
                </div>
                <div class="indicators">
                    <span class="detail-label">Indicators:</span>
                    <ul class="indicators-list"></ul>
                </div>
            </div>

            <div class="traffic-analysis analysis-section">
                <h4>Traffic Analysis</h4>
                <div class="risk-row">
                    <span class="detail-label">Risk Level:</span>
                    <span class="risk-value"></span>
                </div>
                <div class="threats">
                    <span class="detail-label">Active Threats:</span>
                    <ul class="threats-list"></ul>
                </div>
            </div>

            <div class="wps-analysis analysis-section">
                <h4>WPS Analysis</h4>
                <div class="risk-row">
                    <span class="detail-label">Risk Level:</span>
                    <span class="risk-value"></span>
                </div>
                <div class="vulnerabilities">
                    <span class="detail-label">Vulnerabilities:</span>
                    <ul class="vulnerabilities-list"></ul>
                </div>
            </div>

            <div class="channel-analysis analysis-section">
                <h4>Channel Analysis</h4>
                <div class="risk-row">
                    <span class="detail-label">Risk Level:</span>
                    <span class="risk-value"></span>
                </div>
                <div class="interference">
                    <span class="detail-label">Interference Sources:</span>
                    <ul class="interference-list"></ul>
                </div>
                <div class="recommendations">
                    <span class="detail-label">Recommendations:</span>
                    <ul class="recommendations-list"></ul>
                </div>
            </div>

            <div class="rogue-detection analysis-section">
                <h4>Rogue AP Detection</h4>
                <div class="risk-row">
                    <span class="detail-label">Risk Level:</span>
                    <span class="risk-value"></span>
                </div>
                <div class="similar-networks">
                    <span class="detail-label">Similar Networks:</span>
                    <ul class="similar-networks-list"></ul>
                </div>
                <div class="indicators">
                    <span class="detail-label">Indicators:</span>
                    <ul class="indicators-list"></ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedNetwork = null;
        let startTime = null;
        let attemptCounter = 0;
        let investigationActive = false;

        function addTerminalOutput(text, isCommand = false) {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = 'terminal-output';
            
            if (isCommand) {
                line.innerHTML = `<span class="terminal-prompt">$</span> ${text}`;
            } else if (text.startsWith('[ATTEMPT]')) {
                // Special handling for attempt lines to show brute force progress
                const attemptLine = document.createElement('div');
                attemptLine.className = 'attempt-line';
                
                // Extract password from attempt text
                const parts = text.substring(9).split(' ');
                const password = parts[1];
                
                // Create visual representation of brute force
                const chars = password.split('');
                const charContainer = document.createElement('div');
                charContainer.style.display = 'inline-block';
                
                // Show current attempt
                charContainer.innerHTML = `<span style="color: #0f0">Testing: </span>`;
                chars.forEach((char, index) => {
                    const span = document.createElement('span');
                    span.className = 'scrolling-char';
                    span.textContent = char;
                    span.style.animationDelay = `${index * 50}ms`;
                    charContainer.appendChild(span);
                });
                
                // Add attempt counter and speed
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const speed = elapsed > 0 ? Math.floor(attemptCounter / elapsed) : 0;
                const counter = document.createElement('span');
                counter.style.marginLeft = '10px';
                counter.style.color = '#666';
                counter.textContent = `[${attemptCounter}/${maxAttempts} | ${speed}/s]`;
                charContainer.appendChild(counter);
                
                attemptLine.appendChild(charContainer);
                line.appendChild(attemptLine);
            } else if (text.startsWith("Testing '")) {
                // Handle direct testing output
                const attemptLine = document.createElement('div');
                attemptLine.className = 'attempt-line';
                
                // Extract password and progress from text
                const match = text.match(/Testing '(.+)' \((\d+)\/(\d+)\)/);
                if (match) {
                    const [_, password, current, total] = match;
                    attemptCounter = parseInt(current);
                    maxAttempts = parseInt(total);
                    
                    const charContainer = document.createElement('div');
                    charContainer.style.display = 'inline-block';
                    
                    // Show current attempt
                    charContainer.innerHTML = `<span style="color: #0f0">Testing: </span>`;
                    password.split('').forEach((char, index) => {
                        const span = document.createElement('span');
                        span.className = 'scrolling-char';
                        span.textContent = char;
                        span.style.animationDelay = `${index * 50}ms`;
                        charContainer.appendChild(span);
                    });
                    
                    // Add attempt counter and speed
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    const speed = elapsed > 0 ? Math.floor(attemptCounter / elapsed) : 0;
                    const counter = document.createElement('span');
                    counter.style.marginLeft = '10px';
                    counter.style.color = '#666';
                    counter.textContent = `[${current}/${total} | ${speed}/s]`;
                    charContainer.appendChild(counter);
                    
                    attemptLine.appendChild(charContainer);
                    line.appendChild(attemptLine);
                } else {
                    line.textContent = text;
                }
            } else {
                line.textContent = text;
            }
            
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
            
            // Keep only last 100 lines to prevent memory issues
            while (output.children.length > 100) {
                output.removeChild(output.firstChild);
            }
        }

        function handleTerminalInput(event) {
            if (event.key === 'Enter') {
                const input = document.getElementById('terminalInput');
                const command = input.value.trim().toLowerCase();
                input.value = '';
                
                addTerminalOutput(command, true);
                
                switch (command) {
                    case 'help':
                        addTerminalOutput(
                            'Developer by Krisopras Eben Haeezer\n' +
                            'Available commands:\n' +
                            'help     - Show this help message\n' +
                            'status   - Show current investigation status\n' +
                            'rules    - Show security rules and guidelines\n' +
                            'clear    - Clear terminal output'
                        );
                        break;
                    case 'status':
                        const elapsed = Math.floor((Date.now() - startTime) / 1000);
                        const minutes = Math.floor(elapsed / 60);
                        const seconds = elapsed % 60;
                        const speed = elapsed > 0 ? Math.floor(attemptCounter / elapsed) : 0;
                        
                        addTerminalOutput(
                            'Investigation Status:\n' +
                            `Attempts: ${attemptCounter}\n` +
                            `Speed: ${speed}/s\n` +
                            `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`
                        );
                        break;
                    case 'rules':
                        addTerminalOutput(
                            'Security Rules and Guidelines:\n\n' +
                            '1. Authorization Required\n' +
                            '   - This tool is for authorized law enforcement personnel only\n' +
                            '   - Unauthorized use is strictly prohibited\n\n' +
                            '2. Investigation Guidelines\n' +
                            '   - Use simulation mode for testing and training\n' +
                            '   - Real attack mode requires proper authorization\n' +
                            '   - Document all investigation activities\n\n' +
                            '3. Network Safety\n' +
                            '   - Verify target network before investigation\n' +
                            '   - Avoid interference with critical networks\n' +
                            '   - Monitor network stability during investigation\n\n' +
                            '4. Data Protection\n' +
                            '   - Handle discovered credentials with care\n' +
                            '   - Do not share or store passwords insecurely\n' +
                            '   - Clear all data after investigation\n\n' +
                            '5. Legal Compliance\n' +
                            '   - Follow local and federal regulations\n' +
                            '   - Maintain proper investigation records\n' +
                            '   - Report any security incidents immediately'
                        );
                        break;
                    case 'clear':
                        document.getElementById('terminalOutput').innerHTML = '';
                        break;
                    default:
                        addTerminalOutput(`Unknown command: ${command}\nType 'help' for available commands`);
                }
            }
        }

        async function scanNetworks() {
            try {
                document.getElementById('scanBtn').disabled = true;
                document.getElementById('networks').innerHTML = '';
                document.getElementById('results').style.display = 'none';
                document.getElementById('progressContainer').style.display = 'none';
                
                addTerminalOutput('Scanning for networks...');
                
                const response = await fetch('/scan');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                document.getElementById('scanBtn').disabled = false;
                
                if (!data.success) {
                    throw new Error(data.error || 'Scan failed');
                }
                
                if (!data.networks || data.networks.length === 0) {
                    document.getElementById('networks').innerHTML = '<div>No networks found</div>';
                    addTerminalOutput('No networks found');
                    return;
                }
                
                addTerminalOutput(`Found ${data.networks.length} networks`);
                
                document.getElementById('networks').innerHTML = data.networks.map(network => {
                    // Safely get advanced analysis data
                    const securityInfo = network.security_info || {};
                    const advancedAnalysis = securityInfo.advanced_analysis || {};
                    const macSpoofing = advancedAnalysis.mac_spoofing || {};
                    const traffic = advancedAnalysis.traffic || {};
                    const wps = advancedAnalysis.wps || {};
                    const channel = advancedAnalysis.channel || {};
                    const rogueDetection = advancedAnalysis.rogue_detection || {};
                    
                    return `
                        <div class="network" 
                            data-mac-analysis='${JSON.stringify(macSpoofing)}'
                            data-traffic-analysis='${JSON.stringify(traffic)}'
                            data-wps-analysis='${JSON.stringify(wps)}'
                            data-channel-analysis='${JSON.stringify(channel)}'
                            data-rogue-analysis='${JSON.stringify(rogueDetection)}'
                            onclick="selectNetwork('${network.ssid}')">
                            <div class="network-header">
                                <strong>${network.ssid || 'Unknown Network'}</strong>
                                <span class="risk-badge ${(network.risk_level || 'unknown').toLowerCase()}">${network.risk_level || 'Unknown'}</span>
                            </div>
                            <div class="network-details">
                                <div class="detail-row">
                                    <span class="detail-label">BSSID:</span> ${network.bssid || 'Unknown'}
                                </div>
                                <div class="detail-row">
                                    <span class="detail-label">Signal:</span> ${network.signal || 0}%
                                </div>
                                <div class="detail-row">
                                    <span class="detail-label">Security:</span> ${network.security || 'Unknown'}
                                </div>
                                <div class="vulnerabilities">
                                    <div class="detail-label">Vulnerabilities:</div>
                                    <ul class="vuln-list">
                                        ${(network.vulnerabilities || []).map(v => `<li>${v}</li>`).join('')}
                                    </ul>
                                </div>
                                <div class="recommendations">
                                    <div class="detail-label">Recommendations:</div>
                                    <ul class="rec-list">
                                        ${(network.recommendations || []).map(r => `<li>${r}</li>`).join('')}
                                    </ul>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                document.getElementById('scanBtn').disabled = false;
                showError(error.message);
                addTerminalOutput(`Error: ${error.message}`);
            }
        }

        function selectNetwork(ssid) {
            selectedNetwork = ssid;
            document.getElementById('ssid').value = ssid;
            document.getElementById('controlPanel').style.display = 'block';
            document.getElementById('results').style.display = 'none';
            document.getElementById('progressContainer').style.display = 'none';
            
            // Get network data from scan results
            const networkElement = document.querySelector(`.network strong:contains("${ssid}")`).closest('.network');
            const networkData = {
                ssid: ssid,
                bssid: networkElement.querySelector('.bssid').textContent,
                signal: networkElement.querySelector('.signal').textContent,
                security: networkElement.querySelector('.security').textContent,
                security_info: {
                    type: networkElement.querySelector('.security').textContent,
                    advanced_analysis: {
                        mac_spoofing: JSON.parse(networkElement.dataset.macAnalysis || '{}'),
                        traffic: JSON.parse(networkElement.dataset.trafficAnalysis || '{}'),
                        wps: JSON.parse(networkElement.dataset.wpsAnalysis || '{}'),
                        channel: JSON.parse(networkElement.dataset.channelAnalysis || '{}'),
                        rogue_detection: JSON.parse(networkElement.dataset.rogueAnalysis || '{}')
                    }
                }
            };
            
            // Update network details display
            updateNetworkDetails(networkData);
            
            document.querySelectorAll('.network').forEach(el => {
                if (el.querySelector('strong').textContent === ssid) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
            
            addTerminalOutput(`Selected network: ${ssid}`);
        }

        async function startInvestigation(simulationMode = true) {
            try {
                // Clean up any previous investigation
                if (investigationActive) {
                    await sendControl('stop');
                }

                // Reset state
                investigationActive = true;
                attemptCounter = 0;
                startTime = Date.now();
                
                // Validate parameters first
                const minLength = parseInt(document.getElementById('minLength').value);
                const maxLength = parseInt(document.getElementById('maxLength').value);
                const maxAttempts = parseInt(document.getElementById('maxAttempts').value);
                
                // Parameter validation
                if (minLength > maxLength) {
                    throw new Error('Minimum length cannot be greater than maximum length');
                }
                if (minLength < 4 || maxLength > 12) {
                    throw new Error('Length must be between 4 and 12 characters');
                }
                if (maxAttempts < 100 || maxAttempts > 10000) {
                    throw new Error('Max attempts must be between 100 and 10000');
                }
                if (!selectedNetwork) {
                    throw new Error('Please select a network first');
                }

                const startBtn = simulationMode ? 
                    document.getElementById('simulateBtn') : 
                    document.getElementById('crackBtn');
                startBtn.disabled = true;
                
                // Reset display with new parameters
                document.getElementById('progressBar').style.width = '0%';
                document.getElementById('attemptList').innerHTML = '';
                document.getElementById('progressContainer').style.display = 'block';
                document.getElementById('results').style.display = 'none';
                document.getElementById('terminalOutput').innerHTML = '';
                
                // Initialize bruteforce visual with current parameters
                createBruteforceVisual();
                
                const params = {
                    ssid: selectedNetwork,
                    pattern: document.getElementById('pattern').value,
                    min_length: minLength,
                    max_length: maxLength,
                    max_attempts: maxAttempts
                };

                // Log parameters to terminal
                addTerminalOutput(`Starting ${simulationMode ? 'simulation' : 'real attack'} with parameters:`)
                addTerminalOutput(JSON.stringify(params, null, 2));

                const endpoint = simulationMode ? '/simulate' : '/crack';
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();

                // Update visual based on max_length parameter
                if (result.attempt_list) {
                    result.attempt_list.forEach(attempt => {
                        addAttempt(attempt.password, attempt.status);
                        attemptCounter = attempt.attempt;
                        const progress = (attemptCounter / params.max_attempts) * 100;
                        document.getElementById('progressBar').style.width = `${Math.min(100, progress)}%`;
                    });
                }
                
                if (result.success) {
                    document.getElementById('progress').innerHTML = `
                        <div class="success">
                            Investigation successful!<br>
                            Password found: ${result.password}<br>
                            Attempts: ${result.attempts}<br>
                            Time elapsed: ${Math.floor((Date.now() - startTime) / 1000)}s
                        </div>
                    `;
                    updateBruteforceVisual(result.password, 'success');
                    addTerminalOutput(`Success! Password found: ${result.password}`);
                } else {
                    document.getElementById('progress').innerHTML = `
                        <div class="error">
                            Investigation completed without results.<br>
                            Attempts made: ${result.attempts}<br>
                            Time elapsed: ${Math.floor((Date.now() - startTime) / 1000)}s<br>
                            ${result.error ? `Error: ${result.error}` : ''}
                        </div>
                    `;
                    addTerminalOutput(`Investigation failed: ${result.error || 'Password not found'}`);
                }

                document.getElementById('results').style.display = 'block';

            } catch (error) {
                showError(error.message);
                addTerminalOutput(`Error: ${error.message}`);
            } finally {
                if (!investigationActive) {
                    document.getElementById('simulateBtn').disabled = false;
                    document.getElementById('crackBtn').disabled = false;
                }
            }
        }

        function showError(message) {
            const results = document.getElementById('results');
            results.style.display = 'block';
            results.innerHTML = `<div class="error">${message}</div>`;
        }

        function createBruteforceVisual() {
            const visualContainer = document.getElementById('bruteforceVisual');
            visualContainer.innerHTML = '';
            const maxLength = parseInt(document.getElementById('maxLength').value);
            const minLength = parseInt(document.getElementById('minLength').value);
            
            // Create visual representation based on max length
            for (let i = 0; i < maxLength; i++) {
                const charContainer = document.createElement('div');
                charContainer.className = 'char-container';
                // Show different placeholder for required vs optional characters
                const char = i < minLength ? '*' : '?';
                charContainer.innerHTML = `<span class="char">${char}</span>`;
                visualContainer.appendChild(charContainer);
            }
        }

        function updateBruteforceVisual(password, status) {
            const visualContainer = document.getElementById('bruteforceVisual');
            const containers = visualContainer.getElementsByClassName('char-container');
            
            for (let i = 0; i < containers.length; i++) {
                const char = password ? (i < password.length ? password[i] : '*') : '*';
                containers[i].innerHTML = `<span class="char ${status}-char">${char}</span>`;
            }
        }

        function addAttempt(password, status) {
            if (!investigationActive) {
                return; // Exit immediately if investigation is not active
            }
            
            const attemptList = document.getElementById('attemptList');
            const attemptItem = document.createElement('div');
            attemptItem.className = `attempt-item ${status}`;
            attemptItem.textContent = `${password} - ${status}`;
            attemptList.insertBefore(attemptItem, attemptList.firstChild);
            
            // Only add terminal output if investigation is still active
            if (investigationActive) {
                addTerminalOutput(`[ATTEMPT] Testing: ${password}`);
            }
        }

        async function sendControl(action) {
            try {
                const response = await fetch('/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ action })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                if (!result.success) {
                    throw new Error(result.error || 'Control action failed');
                }

                // Stop visual updates when stopping investigation
                if (action === 'stop') {
                    // Set investigation state
                    investigationActive = false;
                    attemptCounter = 0;
                    startTime = null;

                    // Clear all visual elements
                    document.getElementById('bruteforceVisual').innerHTML = '';
                    document.getElementById('progressBar').style.width = '0%';
                    document.getElementById('attemptList').innerHTML = '';
                    
                    // Stop all animations immediately
                    document.querySelectorAll('.scrolling-char, .char').forEach(el => {
                        el.style.animation = 'none';
                        el.style.opacity = '0';
                    });

                    // Reset buttons
                    document.getElementById('simulateBtn').disabled = false;
                    document.getElementById('crackBtn').disabled = false;
                    
                    // Clear terminal and add stop message
                    addTerminalOutput('Investigation stopped - all processes terminated');
                    addTerminalOutput('System reset and ready for new investigation');
                }
                
                // Pause visual updates when pausing investigation
                if (action === 'pause') {
                    document.querySelectorAll('.scrolling-char, .char').forEach(el => {
                        el.style.animationPlayState = 'paused';
                    });
                    addTerminalOutput('Investigation paused');
                }
                
                // Resume visual updates when resuming investigation
                if (action === 'resume' && investigationActive) {
                    document.querySelectorAll('.scrolling-char, .char').forEach(el => {
                        el.style.animationPlayState = 'running';
                    });
                    addTerminalOutput('Investigation resumed');
                }
            } catch (error) {
                addTerminalOutput(`Failed to ${action}: ${error.message}`);
                // Reset state on error
                if (action === 'stop') {
                    investigationActive = false;
                    attemptCounter = 0;
                    startTime = null;
                }
            }
        }

        // Update parameter change handlers
        document.getElementById('minLength').addEventListener('change', function() {
            if (parseInt(this.value) > parseInt(document.getElementById('maxLength').value)) {
                document.getElementById('maxLength').value = this.value;
            }
            createBruteforceVisual();
        });

        document.getElementById('maxLength').addEventListener('change', function() {
            if (parseInt(this.value) < parseInt(document.getElementById('minLength').value)) {
                document.getElementById('minLength').value = this.value;
            }
            createBruteforceVisual();
        });

        // Add cleanup on page unload
        window.addEventListener('beforeunload', async () => {
            if (investigationActive) {
                try {
                    await sendControl('stop');
                } catch (error) {
                    console.error('Failed to cleanup:', error);
                }
            }
        });

        function updateNetworkDetails(network) {
            const detailsSection = document.querySelector('.network-details');
            detailsSection.style.display = 'block';
            
            // Update basic info
            detailsSection.querySelector('.ssid').textContent = network.ssid;
            detailsSection.querySelector('.bssid').textContent = network.bssid;
            detailsSection.querySelector('.signal').textContent = network.signal;
            detailsSection.querySelector('.security').textContent = network.security;
            
            // Update MAC Spoofing Analysis
            const macInfo = network.security_info.advanced_analysis.mac_spoofing;
            updateMacSpoofingInfo(macInfo);
            
            // Update Traffic Analysis
            const trafficInfo = network.security_info.advanced_analysis.traffic;
            updateTrafficAnalysis(trafficInfo);
            
            // Update WPS Analysis
            const wpsInfo = network.security_info.advanced_analysis.wps;
            updateWpsAnalysis(wpsInfo);
            
            // Update Channel Analysis
            const channelInfo = network.security_info.advanced_analysis.channel;
            updateChannelAnalysis(channelInfo);
            
            // Update Rogue AP Detection
            const rogueInfo = network.security_info.advanced_analysis.rogue_detection;
            updateRogueDetection(rogueInfo);
        }

        function updateMacSpoofingInfo(macInfo) {
            const section = document.querySelector('.mac-spoofing');
            section.querySelector('.risk-value')
                .textContent = macInfo.risk_level || 'Unknown';
            
            const indicatorsList = section.querySelector('.indicators-list');
            indicatorsList.innerHTML = '';
            if (macInfo.indicators && macInfo.indicators.length > 0) {
                macInfo.indicators.forEach(indicator => {
                    indicatorsList.innerHTML += `<li>${indicator}</li>`;
                });
            }
        }

        function updateTrafficAnalysis(trafficInfo) {
            const section = document.querySelector('.traffic-analysis');
            section.querySelector('.risk-value')
                .textContent = trafficInfo.risk_level || 'Unknown';
            
            const threatsList = section.querySelector('.threats-list');
            threatsList.innerHTML = '';
            if (trafficInfo.active_threats && trafficInfo.active_threats.length > 0) {
                trafficInfo.active_threats.forEach(threat => {
                    threatsList.innerHTML += `<li>${threat}</li>`;
                });
            }
        }

        function updateWpsAnalysis(wpsInfo) {
            const section = document.querySelector('.wps-analysis');
            section.querySelector('.risk-value')
                .textContent = wpsInfo.risk_level || 'Unknown';
            
            const vulnList = section.querySelector('.vulnerabilities-list');
            vulnList.innerHTML = '';
            if (wpsInfo.vulnerabilities && wpsInfo.vulnerabilities.length > 0) {
                wpsInfo.vulnerabilities.forEach(vuln => {
                    vulnList.innerHTML += `<li>${vuln}</li>`;
                });
            }
        }

        function updateChannelAnalysis(channelInfo) {
            const section = document.querySelector('.channel-analysis');
            section.querySelector('.risk-value')
                .textContent = channelInfo.risk_level || 'Unknown';
            
            const interfList = section.querySelector('.interference-list');
            interfList.innerHTML = '';
            if (channelInfo.interference_sources && channelInfo.interference_sources.length > 0) {
                channelInfo.interference_sources.forEach(source => {
                    if (typeof source === 'object') {
                        interfList.innerHTML += `<li>Network: ${source.ssid} (Channel ${source.channel})</li>`;
                    } else {
                        interfList.innerHTML += `<li>${source}</li>`;
                    }
                });
            }
            
            const recomList = section.querySelector('.recommendations-list');
            recomList.innerHTML = '';
            if (channelInfo.recommendations && channelInfo.recommendations.length > 0) {
                channelInfo.recommendations.forEach(rec => {
                    recomList.innerHTML += `<li>${rec}</li>`;
                });
            }
        }

        function updateRogueDetection(rogueInfo) {
            const section = document.querySelector('.rogue-detection');
            section.querySelector('.risk-value')
                .textContent = rogueInfo.risk_level || 'Unknown';
            
            const similarList = section.querySelector('.similar-networks-list');
            similarList.innerHTML = '';
            if (rogueInfo.similar_networks && rogueInfo.similar_networks.length > 0) {
                rogueInfo.similar_networks.forEach(network => {
                    similarList.innerHTML += `
                        <li>
                            SSID: ${network.ssid}<br>
                            BSSID: ${network.bssid}<br>
                            Similarity: ${(network.similarity * 100).toFixed(1)}%
                        </li>`;
                });
            }
            
            const indicatorsList = section.querySelector('.indicators-list');
            indicatorsList.innerHTML = '';
            if (rogueInfo.indicators && rogueInfo.indicators.length > 0) {
                rogueInfo.indicators.forEach(indicator => {
                    indicatorsList.innerHTML += `<li>${indicator}</li>`;
                });
            }
        }
    </script>
</body>
</html>